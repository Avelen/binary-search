<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">

    <style>
        body {
            margin: 30px;
        }

        pre {
            background: aliceblue;
            padding: 10px;
            white-space: normal;
        }
    </style>
    <title>Title</title>
</head>
<body>

<h1>Algorithm tests</h1>

<h3>Exercise</h3>

<h4>Most effective search</h4>

<p>You have a sorted list of 128 names, and you are looking for a value in it using a binary search. What is the maximum number of checks it can take? Suppose the size of the list is doubled. How would the maximum number of checks change?
</p>

<pre id="">
        <p>Name list:</p>
        <p id="task-1"></p>
        <br>
        <p>Random search result:</p>
        <p id="nameResult"></p>
        <p>Max operation count: <span id="algSum"></span></p>

    </pre>

<h4>Big O</h4>

<p>Приведите время выполнения <b>O-большое</b> для каждого из следующих сценариев.
<ol>
    <li>Известна фамилия, нужно найти номер в телефонной книге.</li>
    <li>
        Известен номер, нужно найти фамилию в телефонной книге.
    </li>
    <li>
        Нужно прочитать телефоны всех людей в телефонной книге.
    </li>
    <li>
        Нужно прочитать телефоны всех людей, фамилии которых начинаются с буквы <b>А</b>
    </li>
</ol>
</p>

<pre>
        // here will be a code result


    </pre>

<h4>Data structure</h4>

<p>
    Допустим, вы строите приложение для управления финансами.
    1. Продукты
    2. Кино
    3. Велосипедный клуб

    Ежедневно вы записываете все свои траты. В конце месяца вы анализируете расходы и вычисляете, сколько денег было
    потрачено. При
    работе с данными выполняется множество операций вставки и относительно немного операций чтения. Какую структуру
    использовать -
    массив или список?
</p>

<pre>
        // here will be a code result


    </pre>

<p>
    Допустим, вы пишете приложение для приема заказов от посетителей
    ресторана. Приложение должно хранить список заказов. Официанты
    добавляют заказы в список, а повара читают заказы из списка и выполняют их. Заказы образуют очередь: официанты
    добавляют заказы
    в конец очереди, а повар берет первый заказ из очереди и начинает
    готовить. Какую структуру данных вы бы использовали для реализации этой
    очереди: массив или связанный список? (Подсказка: связанные списки
    хорошо подходят для вставки/удаления, а массивы - для произвольного доступа к элементам. Что из этого понадобится в
    данном случае?)

    Проведем мысленный эксперимент. Допустим, Facebook хранит
    список имен пользователей. Когда кто-то пытается зайти на сайт
    Facebook, система пытается найти имя пользователя. Если имя входит в список имен зарегистрированных пользователеи,
    то вход разрешается.
    Пользователи приходят на Facebook достаточно часто, поэтому
    поиск по списку имен пользователей будет выполняться часто. Будем
    считать, что Facebook использует бинарный поиск для поиска в списке. Бинарному поиску необходим произвольный доступ
    - алгоритм
    должен мгновенно обратиться к среднему элементу текущей части
    списка. Зная это обстоятельство, как бы вы реализовали список пользователей: в виде массива ил:и в виде связанного
    списка?

    Пользователи также довольно часто создают новые учетные записи на
    Facebook. Предположим, вы решили использовать массив для хранения списка пользователей. Какими недостатками обладает
    массив дл:я
    выполнения вставки? Допустим, вы используете бинарный поиск для
    нахождения учетных данных. Что произойдет при добавлении новых
    пользователей в массив?

    В действительности Facebook не использует ни массив, ни связанный
    список для хранения информации о пользователях. Рассмотрим гибридную структуру данных: массив связанных списков.
    Имеется массив из 26 элементов.
    Каждый элемент содержит ссылку на связанный
    список. Например, первый элемент массива указывает на связанный
    список всех имен пользователей, начинающихся на букву �л�. Второй элемент указывает на связанныи список всех имен
    пользователем,
    начинающихся на букву в, и т. д.

    Предположим, пользователь с именем �Adit в� регистрируется на
    Facebook и вы хотите добавить его в список. Вы обращаетесь к элементу 1 массива, находите связанный список элемента
    1 и добавляете
    �Adit в� в конец списка. Теперь предположим, что зарегистрировать
    нужно пользователя �zakhir Н•. Вы обращаетесь к элементу 26, который содержит связанный список всех имен,
    начинающихся с z,
    и проверяете, присутствует ли �zakhir н� в этом списке.
    Теперь сравните эту гибридную структуру данных с массивами и связанными списками. Будет ли она быстрее или медленнее
    каждой исходной структуры при поиске и вставке? Приводить �о-большое� не
    нужно, просто выберите одно из двух: быстрее или медленнее.
</p>

<pre>
        // here will be a code result


    </pre>
</body>

<script src="main.js">
</script>
</html>